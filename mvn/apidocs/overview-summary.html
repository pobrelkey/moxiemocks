<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_45) on Tue Aug 18 22:55:09 BST 2015 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Overview (Moxie 1.1.1-SNAPSHOT API)</title>
<meta name="date" content="2015-08-18">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script type="text/javascript" src="script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Overview (Moxie 1.1.1-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">Moxie 1.1.1-SNAPSHOT API</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block">
    Moxie is a Java library for creating <a target="_top" href="http://www.mockobjects.com/">mock objects</a> in unit tests.</div>
</div>
<p>See: <a href="#overview.description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="moxie/package-summary.html">moxie</a></td>
<td class="colLast">
<div class="block">Moxie: a wicked good Java mocking library.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="moxie/hamcrest/package-summary.html">moxie.hamcrest</a></td>
<td class="colLast">
<div class="block">This package contains <a href="http://code.google.com/p/hamcrest/">Hamcrest</a> matchers
 and related classes used internally by Moxie (though you're welcome to use them
 in your tests as well).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="org/powermock/api/extension/proxyframework/package-summary.html">org.powermock.api.extension.proxyframework</a></td>
<td class="colLast">
<div class="block">This package contains internal glue code for integration with PowerMock.</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="contentContainer"><a name="overview.description">
<!--   -->
</a>
<div class="block"><p>
    Moxie is a Java library for creating <a target="_top" href="http://www.mockobjects.com/">mock objects</a> in unit tests.
    It aims to be the "nicest" and easiest-to-use mocking library around, with a consistent syntax that rankles less
    than other mocking libraries currently available.
</p>

<p>
    This page gives an overview of Moxie; for more information, you may also be interested in Moxie's
    <a target="_top" href="http://code.google.com/p/moxiemocks">Google Code page</a> and
    <a target="_top" href="http://moxiemocks.org/mvn/">Maven-generated project documentation</a>.
</p>

<h2>Installation</h2>

<p>
    Grab Moxie from our Google Code <a href="http://code.google.com/p/moxiemocks/downloads/list">download page</a>, or use Maven:
</p>
<blockquote><pre>
&lt;dependency&gt;
    &lt;groupId&gt;org.moxiemocks&lt;/groupId&gt;
    &lt;artifactId&gt;moxie&lt;/artifactId&gt;
    &lt;version&gt;1.1.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>
</blockquote>
<p>
    Note that if you're manually installing Moxie, you may also want the following jars:
<ul>
    <li><a target="_top" href="http://code.google.com/p/hamcrest/">Hamcrest</a> 1.1 or later (note that the
        <a target="_top" href="http://junit.sourceforge.net/">JUnit</a> 4 jar contains the core Hamcrest classes, which will enable
        all
        functionality except some of the text matchers on <a href="moxie/MoxieMatchers.html" title="class in moxie"><code>MoxieMatchers</code></a>)
    </li>
    <li><a target="_top" href="http://cglib.sourceforge.net/">cglib</a> 2.1_3 or later (only if you want to mock concrete classes
        or use spies - not needed for interface mocks)
    </li>
    <li><a target="_top" href="http://www.objenesis.org/">Objenesis</a> 1.2 or later (only if you want to mock concrete classes
        that don't have no-arg constructors)
    </li>
    <li><a target="_top" href="http://www.powermock.org/">PowerMock</a> 1.4.9 or later (only if you want to mock private or final
        methods, constructors or static methods on concrete classes)</li>
</ul>
</p>

<h2>Examples</h2>

<p>
    Moxie has extensive javadoc which covers every public method - the following examples are meant to be a quick
    introductory sketch.
</p>

<p>
    Simple example: assume we're testing a <code>Rot13List</code> - a hypothetical class which wraps a
    <code>List&lt;String&gt;</code>. It encodes item values with the
    <a target="_top" href="http://en.wikipedia.org/wiki/ROT13">ROT13 cipher</a> when writing them to the underlying list,
    and decodes them on reads.
</p>

<p>
    To test <code>Rot13List</code>, we'll want to create and inject a mock <code>List</code> to stand in for the
    underlying list. (Note that so long as CGLib and ASM are on your classpath, you can mock classes as well as
    interfaces - though you can't mock <code>final</code> classes or methods.)
</p>
<blockquote><pre>
List mock = <b>Moxie.mock(List.class);</b>
<b>Moxie.expect(mock).will().add("uryyb jbeyq");</b>
Rot13List rot13 = new Rot13List(mock);
rot13.add("hello world");
<b>Moxie.verify(mock);</b>
</pre>
</blockquote>
<p>
    You can have mocked methods return values or throw exceptions.
</p>
<blockquote><pre>
List mock = Moxie.mock(List.class);
Moxie.expect(mock).<b>willReturn("uryyb jbeyq")</b>.on().get(0);
Moxie.expect(mock).<b>willThrow(new IndexOutOfBoundsException())</b>.on().get(1);
Rot13List rot13 = new Rot13List(mock);
String result = rot13.get(0);
assertEquals("hello world", result);
try {
    rot13.get(1);
} catch (IndexOutOfBoundsException e) {
    // expected
}
Moxie.verify(mock);
</pre>
</blockquote>
<p>
    Here we check that a method will be called a certain number of times.
</p>
<blockquote><pre>
List mock = Moxie.mock(List.class);
Moxie.expect(mock).<b>times(5)</b>.will().add("uryyb jbeyq");
Rot13List rot13 = new Rot13List(mock);
for (int i = 0; i < 5; i++) {
    rot13.add("hello world");
}
Moxie.verify(mock);
</pre>
</blockquote>
<p>
    Note that you can also specify <a href="moxie/Cardinality.html#atLeast-int-"><code>atLeast(x)</code></a>, <a href="moxie/Cardinality.html#atMost-int-"><code>atMost(x)</code></a>,
    <a href="moxie/Cardinality.html#times-int-int-"><code>times(a,b)</code></a> (between a and b times), etc.
</p>

<p>
    As in other mocking libraries, Moxie can perform flexible matching on parameters to mocked calls.
</p>
<blockquote><pre>
List mock = Moxie.mock(List.class);
Moxie.expect(mock).times(3).will().add(<b>Moxie.startsWith("uryyb")</b>);
Rot13List rot13 = new Rot13List(mock);
rot13.add("hello world");
rot13.add("hello Cleveland");
rot13.add("hellojed");
Moxie.verify(mock);
</pre>
</blockquote>
<p>
    Moxie has a range of built-in matcher methods you can use (see <a href="moxie/MoxieMatchers.html" title="class in moxie"><code>MoxieMatchers</code></a>), including
    one that will call
    any Hamcrest matcher (see <a href="moxie/MoxieMatchers.html#argThat-org.hamcrest.Matcher-"><code>argThat()</code></a>).
</p>

<p>
    By default, Moxie doesn't verify the ordering of methods on individual mocks. It will do this if you specify
    <a href="moxie/MoxieOptions.html#ORDERED"><code>MoxieOptions.ORDERED</code></a> when creating the mock:
</p>
<blockquote><pre>
List mock = Moxie.mock(List.class, <b>MoxieOptions.ORDERED</b>);
Moxie.expect(mock).will().add("sbb");
Moxie.expect(mock).will().add("one");
Moxie.expect(mock).will().add("onm");
Rot13List rot13 = new Rot13List(mock);
rot13.add("foo");
rot13.add("bar");
rot13.add("baz");
Moxie.verify(mock);
</pre>
</blockquote>
<p>
    You can also check call ordering across mocks by using <a href="moxie/Group.html" title="interface in moxie"><code>Group</code></a>s:
</p>
<blockquote><pre>
List mockA = Moxie.mock(List.class);
List mockB = Moxie.mock(List.class);
<b>Group group = Moxie.group();</b>
Moxie.expect(mockA)<b>.inGroup(group)</b>.will().add("sbb");
Moxie.expect(mockB)<b>.inGroup(group)</b>.will().add("one");
Moxie.expect(mockA)<b>.inGroup(group)</b>.will().add("onm");
Rot13List rot13A = new Rot13List(mockA);
Rot13List rot13B = new Rot13List(mockB);
rot13A.add("foo");
rot13B.add("bar");
rot13A.add("baz");
Moxie.verify(mockA, mockB, <b>group</b>);
</pre>
</blockquote>
<p>
    In addition to creating mocks, Moxie also allows you to create spy objects, an expectation-checking wrapper around
    a real object:
</p>
<blockquote><pre>
<b>List&lt;String&gt; spy = Moxie.spy(Arrays.asList("mreb", "bar", "gjb"));</b>
Moxie.expect(spy).will().get(1);
Rot13List rot13 = new Rot13List(spy);
String result = rot13.get(1);
assertEquals("one", result);
Moxie.verify(spy);
</pre>
</blockquote>
<p>
    To verify that an object being wrapped by a spy returns/throws a given value, we introduce two new methods:
</p>
<blockquote><pre>
List&lt;String&gt; spy = Moxie.spy(Arrays.asList("mreb", "bar", "gjb"));
Moxie.expect(spy).<b>willReturnVerified("bar")</b>.on().get(1);
Moxie.expect(spy).<b>willThrowVerified(Moxie.isA(IndexOutOfBoundsException.class))</b>.on().get(3);
Rot13List rot13 = new Rot13List(spy);
String result = rot13.get(1);
assertEquals("one", result);
try {
    rot13.get(3);
} catch (IndexOutOfBoundsException e) {
    // expected - thrown by underlying
}
Moxie.verify(spy);
</pre>
</blockquote>
<p>
    In addition to traditional expectation-driven mocking, Moxie also supports the "state-based testing" approach
    to mocking popularized by <a target="_top" href="http://www.mockito.org/">Mockito</a>, in which checks are performed against mocks
    after the fact to determine whether the desired methods were called. Note that when using this approach we need to
    create our mocks using <a href="moxie/MoxieOptions.html#PERMISSIVE"><code>MoxieOptions.PERMISSIVE</code></a>, so that the mocks won't throw
    an exception when an unexpected method is called.
</p>
<blockquote><pre>
List mock = Moxie.mock(List.class, <b>MoxieOptions.PERMISSIVE</b>);
<b>Moxie.stub(mock).willReturn("bar").on().get(1);</b>
Rot13List rot13 = new Rot13List(mock);
String result = rot13.get(1);
assertEquals("one", result);
rot13.add("hello world");
<b>Moxie.check(mock).got().get(1);</b>
<b>Moxie.check(mock).got().add("uryyb jbeyq");</b>
<b>Moxie.verifyNothingElseHappened(mock);</b>
</pre>
</blockquote>
<p>
    For clarity, the examples here have been presented with explicit setup/verification of mocks. Under JUnit, you can
    use <a href="moxie/MoxieRule.html" title="class in moxie"><code>MoxieRule</code></a> or <a href="moxie/MoxieRunner.html" title="class in moxie"><code>MoxieRunner</code></a> to have your mocks automatically
    populated into fields on your test
    instances, and to automatically verify your mocks at the end of the test; see the documentation for those classes
    for more information.
</p>
<blockquote><pre>
&#64;org.junit.Rule
MoxieRule rule = new MoxieRule();

&#64;Mock
List&lt;String&gt; mock;

&#64;Test
public void simpleExample() {
    // no need to create mocks explicitly - these are created before any &#64;Before methods are called
    Moxie.expect(mock).will().add("uryyb jbeyq");
    Rot13List rot13 = new Rot13List(mock);
    rot13.add("hello world");
    // no need to verify() - MoxieRule handles this after any @After methods
}
</pre>
</blockquote>

<h2>Some Notes on Design and Syntax</h2>

<p>
    Moxie was born primarily out of frustration with the syntax of existing mocking libraries, on a long-running
    (four years, 100-plus iterations) project that used no fewer than four different mocking libraries
    (<a target="_top" href="http://www.jmock.org/jmock1.html">JMock 1</a>, <a target="_top" href="http://www.jmock.org/">JMock 2</a>,
    <a target="_top" href="http://easymock.org/">EasyMock</a>, <a target="_top" href="http://www.mockito.org/">Mockito</a>) in different parts of the code.
    Goals for the syntax and the library were as follows:
</p>
<dl>
    <dt><b>Be refactorable</b></dt>
    <dd><p>Using a modern IDE to rename methods and add/remove/reorder parameters should induce minimal test breakage
        <i>ipso facto</i>.</p></dd>
    <dt><b>Ideally express each expectation as a single Java statement</b></dt>
    <dd><p>JMock 1 did this, but its dated, unrefactorable syntax makes it unsuitable for new projects. EasyMock
        comes close, but breaks down with an inconsistent, two-statement syntax for non-trivial expectations on
        void methods.</p></dd>
    <dt><b>No anonymous inner classes</b></dt>
    <dd><p>JMock 2's syntax, while powerful and festooned with bells and whistles, is quite verbose; most people's needs
        can be satisfied with a simpler syntax. Anonymous inner classes also tend to conflict with the previous
        point.</p></dd>
    <dt><b>Be consistent for <code>void</code> and non-<code>void</code> methods</b></dt>
    <dd><p>Some things must be accomplished differently in EasyMock and Mockito depending on whether the method
        in question returns a value; Moxie aims to accomplish things the same way every time.</p></dd>
    <dt><b>No modal mocks</b></dt>
    <dd><p>
        In other words, mocks should not need to be transitioned from a "setup" state to an "active" state in order
        to be used, as one does in EasyMock using the <code>replay()</code> method.
    </p>

        <p>
            Some people have reported that Moxie's syntax sounds stilted, as the method involved in an expectation
            appears
            at the very end of the line - after return values, etc. are specified - rather than at the start. Compare
            the following two identical statements:
        </p>
        <blockquote><pre>
Moxie.expect(mock).andReturn("result").times(3).on().<b>someMethod()</b>;
EasyMock.expect(<b>mock.someMethod()</b>).times(3).andReturn("result");
</pre>
        </blockquote>
        <p>
            Moxie's syntax is a direct consequence of avoiding modal mocks (and keeping the API consistent for <code>void</code>
            methods). The <code>on()</code> method creates a proxy separate from the mock itself, on which one calls the
            method
            to be expected. By doing this we avoid having to call methods on the mock during setup, which would require
            mocks
            to be modal.
        </p></dd>
    <dt><b>Support both expectation-driven and post-hoc check-driven mocking</b></dt>
    <dd><p>
        Mockito presents an interesting new paradigm for mocking, in which behavior isn't verified by setting
        expectations
        on mocks ahead of time, but rather through spot checks on mocks after the mock is used. Proponents say this
        approach
        is less brittle and keeps tests focused on checking what matters to the test, rather than requiring that many
        boilerplate expectations be set in every test.
    </p>

        <p>
            Personally I still prefer the traditional, more restrictive style of expectation-driven mocking - but don't
            think
            the Mockito approach is complete rubbish either. So I decided to support both approaches in Moxie for
            various reasons - partly to accommodate both approaches on large code bases/teams, but mostly because I
            thought
            people might find it interesting to experiment with the end result. My advice would be to stick with one
            approach
            or the other in your tests; while it's possible to intermix the two, you'll most likely end up with complex,
            incomprehensible tests of dubious value.
        </p></dd>
    <dt><b>Humane interface</b></dt>
    <dd><p>Devising and keeping to natural-sounding DSL isn't easy. In order to provide a more flexible DSL whose calls
        sound "nicer" in a wider range of circumstances and are easier to remember, Moxie includes a number of synonyms
        for common methods. For example, in <a href="moxie/Expectation.html" title="interface in moxie"><code>Expectation</code></a>, <a href="moxie/Expectation.html#willReturn-R-"><code>willReturn()</code></a> and
        <a href="moxie/Expectation.html#andReturn-R-"><code>andReturn()</code></a> do the same thing, as do
        <a href="moxie/ObjectExpectation.html#on--"><code>on()</code></a>,
        <a href="moxie/ObjectExpectation.html#when--"><code>when()</code></a> and <a href="moxie/ObjectExpectation.html#will--"><code>will()</code></a>.</p>

        <p>This approach is borrowed from Ruby, whose class library contains many synonyms for common methods. (Example:
            in Ruby you don't need to remember whether the method on an <code>Array</code> that tells you how many items
            it contains is called <code>length</code> or <code>size</code>; the two methods do the same thing.)
        </p></dd>
</dl>

<h2>Release Notes</h2>
<h4>Release 1.1 - 28 January 2014</h4>
<ul>
    <li>Many new API methods to take advantage of JDK 1.8 lambda syntax.</li>
    <li>Internal Hamcrest matchers exposed for general use.</li>
    <li>Various bug fixes - notably fixing a brown-paper-bag bug involving PowerMock support.</li>
</ul>
<h4>Release 1.0 - 16 April 2012</h4>
<ul>
    <li>Optional integration with <a target="_top" href="http://www.objenesis.org/">Objenesis</a>
        so that concrete mocks can be instantiated without invoking a live constructor.</li>
    <li>Optional integration with <a target="_top" href="http://www.powermock.org/">PowerMock</a>
        to enable mocking of final, private, static and constructor methods.</li>
    <li><a href="moxie/MoxieOptions.html#PARTIAL"><code>PARTIAL</code></a> mocking support - lets you mock some methods on a concrete class
        but have others call to the underlying implementation.</li>
    <li>Special <a href="moxie/MoxieMatchers.html#captureTo-java.util.Collection-"><code>captureTo()</code></a> family of matcher methods to
        enable capture of arguments passed to mock invocations.</li>
    <li>Performance improvement: Moxie now captures far fewer debugging stack traces unless the
        <a href="moxie/MoxieOptions.html#TRACE"><code>TRACE</code></a> option is given. With this improvement, Moxie is now
        <a target="_top" href="http://code.google.com/p/moxiemocks/wiki/MockingLibraryPerformance">faster</a>
        than any other modern mocking library.</li>
    <li>The Moxie jar may well be a valid OSGi bundle now.  I haven't tested this - feedback, good or bad, is welcome.</li>
    <li>Bug fixes, API tweaks.</li>
</ul>
<h4>Release 0.9 - 1 November 2010</h4>
<ul>
    <li>Moxie now supports "consecutive-calls" behavior on mock methods - e.g. methods that return a different value on successive calls.</li>
    <li>Improved error messages for unexpected-invocation errors.</li>
</ul>
<h4>Release 0.3 - 6 July 2010</h4>
<ul>
    <li>Fixing <a target="_top" href="http://code.google.com/p/moxiemocks/issues/detail?id=1&can=1">bug 1</a>:
        <a href="moxie/MoxieRunner.html" title="class in moxie"><code>MoxieRunner</code></a> not setting up mocks before <code>&#64;Before</code> methods are run.
    </li>
    <li>Introduced <a href="moxie/MoxieRule.html" title="class in moxie"><code>MoxieRule</code></a> as a more modern alternative to
        <a href="moxie/MoxieRunner.html" title="class in moxie"><code>MoxieRunner</code></a> in JUnit 4.</li>
    <li>Introduced non-static <a href="moxie/MoxieControl.html" title="interface in moxie"><code>MoxieControl</code></a> as an alternative to static methods
        on <a href="moxie/Moxie.html" title="class in moxie"><code>Moxie</code></a>.</li>
    <li>Better validation, and failure modes when not valid, for expectations.</li>
    <li>Cleaned up/rewrote dcumentation.</li>
    <li>Minor API cleanups.</li>
</ul>
<h4>Release 0.2.1 - 1 July 2010</h4>
<ul>
    <li>Initial release to Maven central repository.</li>
</ul>
<h4>Release 0.2 - 25 June 2010</h4>
<ul>
    <li>Fixed bug in Errors thrown when expectations/checks fail - expected/invoked methods were not being properly
        displayed.
    </li>
</ul>
<h4>Release 0.1 - 23 June 2010</h4>
<ul>
    <li>Initial public release.</li>
</ul>

<p></div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd><a target="_top" href="http://moxiemocks.org/contact-rob.html">Rob Pelkey</a>
</p></dd>
</dl>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2015 <a href="http://moxiemocks.org/">Moxie Contributors</a>. All Rights Reserved.</small></p>
</body>
</html>
